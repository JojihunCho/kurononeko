# 암호

## 좋은 암호란?

암호학에서 말하고자 하는 **좋은 암호**란 *뚫리지 않는 암호*를 말하는 것이 아닙니다. 물론 *뚫리지 않는 암호*가 있다면 더할 나위 없이 좋겠지만 그러기에는 푸는 사람도 암호를 만드는 사람 만큼이나(~~혹은 더~~) 똑똑하기 때문이죠.

우리가 만들어야 할 **좋은 암호**는 암호를 풀 이유가 없도록 만드는 암호입니다. 이게 무슨 소리 냐구요? 

암호를 푸는 시간과 필요한 노력이 암호를 풀었을 때 얻을 보상보다 적다면 누구도 암호를 풀고 싶지 않겠죠? 바로 그걸 말하는 거랍니다.

그래서 오늘은 **좋은 암호**를 만들어 보고자 합니다.



## 고전 암호

과거에는 암호를 풀 만한 장치가 특별히 있지 않았기 때문에 간단한 암호라도 푸는데 매우 오래 걸리곤 했습니다. 따라서 그렇게 복잡하지 않지만 푸는데 오래 걸려버리면 **좋은 암호**가 되는 것이지요.

주로 사용되던 고전 암호화의 방식으로는 **치환**과 **자리바꿈**이 있습니다. 

가장 대표적인 단순**치환**방식의 방법으로는 *카이사르 암호화*가 있습니다. 이것은 A-Z의 알파벳을 주어진 *key*만큼 shift 하여 암호화 합니다. 즉 *key*가 3 이라면 `A`가 `D`가 되겠죠.

이 방법의 가장 큰 문제는 **문자의 출현 빈도**를 숨길 수 없다는 것입니다. 한글은 좀 더 복잡하겠지만, 영어의 경우 문자의 출현 빈도 순으로 암호를 해독하는 모습을 자주 볼 수 있는데요, 그만큼 주어진 정보가 적을 때에는 자주 사용했던 방법입니다. 

이 문제를 해결하기위해 여러 키로 여러번 치환하자는 **다중 치환** 방식의 알고리즘도 있습니다. *Vigenere*방식이 대표적인 **다중 치환** 알고리즘 인데요, 예를들어 `(2, 8, 5, 7, 4)` 를 *key*로 가지는 *Vigenere* 암호화는 "icewall"이라는 평문에 대해 `i`와 첫번 째 `l`은 2의 key를 가지고 암호화 되고, `c`와 두번째 `l`은 8의 키를 가지고 암호화 됩니다.

**자리바꿈** 암호화는 평문을 구성하는 글자들의 위치를 바꾸는 방식을 말합니다. 다음과 같은 열 기준 암호화는 간단한 **자리바꿈** 암호화의 예제 입니다.

`ABCDEFGHIJKLMNOPQRSTUVWXYZABCD`에 대해 *key*를 6으로 하면

| **`ABCDEF`** |
| :----------: |
| **`GHIJKL`** |
| **`MNOPQR`** |
| **`STUVWX`** |
| **`YZABCD`** |
|              |

가 되고 이를 열 기준으로 읽으면 `AGMSY BHNTZ CIOUA DJPVB EKQWC FLRXD`가 됩니다.

이를 여러번 반복하면 꽤나 알기 어려운 암호가 될 수 있습니다.

## 고전암호 해독

그러면 이런 고전 암호는 어떻게 해독할 수 있을까요?

보통 앞서 문제점으로 언급된 **문자의 출현 빈도**를 통해 파악할 수 있습니다. 다음과 같은 통계적 기법으로 해석하곤 합니다.

- `e, t, a, o`등의 문자는 다른 문자들에 비해 출현 빈도가 매우 높다.
- 단어 시작에서는 `t`가 가장 많이 사용되고 `e`는 끝에서 가장 많이 사용된다.
- 길이가 1인 단어는 `a`일 확률이 높다.
- 길이가 2인 단어중 많이 사용되는 단어는 `to`와 `in`이다.
- 길이가 3인 가장 많이 사용되는 조합은 `ing`, `ion,` `ent` 등이 있다.

물론 우리는 좋은 컴퓨터가 있기 때문에 일일히 넣어보는 **Brute Force** 방법을 사용할 수 도 있습니다.


## 문제

그래서 준비했습니다.
아래의 암호문을 복호화 하면 됩니다.

여러분의 컴퓨팅 성능을 고려하여 키의 크기는 그렇게 크지 않습니다. 또 알파뱃 대문자로만 이루어 져 있습니다.

#### 암호문 1 

이 암호는 **치환** 방식으로 암호화 되어있습니다.
`QUXAFFPVPJTZYHIGLHRIKTJMPF`

#### 암호문 2

이 암호는 **자리바꿈** 방식으로 암호화 되어 있습니다.
`MKIEALRAAIBTOAERATOHSSNWRYAAAECWLGETGNUYURGETOTIIASEIAAA`

하나씩 대입해 보는 방법은 꽤 오래걸리기 때문에 여러분은 파이썬 코드를 통해서 주어진 암호를 잘 풀었는지 확인해 볼 수 있습니다.

압축 파일 내부의 `sample.py` 파일을 참조해서 코드를 작성해 보세요. (*파이썬 버전 3*)
